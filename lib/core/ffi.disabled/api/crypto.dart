// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `passphrase_to_seed`

/// Encodes a file to .pnk format
///
/// # Arguments
/// * `input_path` - Path to the source file
/// * `output_path` - Path for the output .pnk file
/// * `passphrase` - 9-character passphrase used as seed
///
/// # Returns
/// * `Ok(())` on success
/// * `Err(String)` on failure
void encodeToPnk(
        {required String inputPath,
        required String outputPath,
        required String passphrase}) =>
    RustLib.instance.api.crateApiCryptoEncodeToPnk(
        inputPath: inputPath, outputPath: outputPath, passphrase: passphrase);

/// Decodes a .pnk file to a temporary directory
///
/// # Arguments
/// * `input_path` - Path to the .pnk file
/// * `output_dir` - Directory to extract the file to
///
/// # Returns
/// * `Ok(String)` - The filename of the extracted file
/// * `Err(String)` on failure
String decodeFromPnk({required String inputPath, required String outputDir}) =>
    RustLib.instance.api.crateApiCryptoDecodeFromPnk(
        inputPath: inputPath, outputDir: outputDir);

/// Decodes a .pnk file with auto-detection of payload type
///
/// # Arguments
/// * `input_path` - Path to the .pnk file
/// * `output_dir` - Directory to extract files to
///
/// # Returns
/// * `Ok(Vec<String>)` - List of extracted filenames
/// * `Err(String)` on failure
List<String> decodeFromPnkAuto(
        {required String inputPath, required String outputDir}) =>
    RustLib.instance.api.crateApiCryptoDecodeFromPnkAuto(
        inputPath: inputPath, outputDir: outputDir);

/// Deletes a temporary file
///
/// # Arguments
/// * `path` - Path to the file to delete
///
/// # Returns
/// * `Ok(())` on success
/// * `Err(String)` on failure
void deleteTempFile({required String path}) =>
    RustLib.instance.api.crateApiCryptoDeleteTempFile(path: path);

/// Deletes a temporary directory and all its contents
///
/// # Arguments
/// * `path` - Path to the directory to delete
///
/// # Returns
/// * `Ok(())` on success
/// * `Err(String)` on failure
void deleteTempDir({required String path}) =>
    RustLib.instance.api.crateApiCryptoDeleteTempDir(path: path);

/// Hashes a passphrase for secure storage
///
/// # Arguments
/// * `passphrase` - The passphrase to hash
///
/// # Returns
/// * The hashed passphrase as a hex string
String hashPassphrase({required String passphrase}) =>
    RustLib.instance.api.crateApiCryptoHashPassphrase(passphrase: passphrase);

/// Verifies a passphrase against a stored hash
///
/// # Arguments
/// * `passphrase` - The passphrase to verify
/// * `hash` - The stored hash to compare against
///
/// # Returns
/// * `true` if the passphrase matches, `false` otherwise
bool verifyPassphrase({required String passphrase, required String hash}) =>
    RustLib.instance.api
        .crateApiCryptoVerifyPassphrase(passphrase: passphrase, hash: hash);

/// Hashes a PIN for secure storage
///
/// # Arguments
/// * `pin` - The PIN to hash
///
/// # Returns
/// * The hashed PIN as a hex string
String hashPin({required String pin}) =>
    RustLib.instance.api.crateApiCryptoHashPin(pin: pin);

/// Verifies a PIN against a stored hash
///
/// # Arguments
/// * `pin` - The PIN to verify
/// * `hash` - The stored hash to compare against
///
/// # Returns
/// * `true` if the PIN matches, `false` otherwise
bool verifyPin({required String pin, required String hash}) =>
    RustLib.instance.api.crateApiCryptoVerifyPin(pin: pin, hash: hash);

/// Decodes a .pnk file and returns its contents as bytes
/// Useful for thumbnails and small files that fit in memory
///
/// # Arguments
/// * `input_path` - Path to the .pnk file
///
/// # Returns
/// * `Ok(Vec<u8>)` - The decoded file contents
/// * `Err(String)` on failure
Uint8List decodeToBytes({required String inputPath}) =>
    RustLib.instance.api.crateApiCryptoDecodeToBytes(inputPath: inputPath);
